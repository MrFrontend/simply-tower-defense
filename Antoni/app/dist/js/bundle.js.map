{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/typescript/Enemy.ts","src/typescript/TowerDefenseGame.ts","src/typescript/TowerDefenseMap.ts","src/typescript/main.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Enemy","rootElement","this","enemyWidth","enemyHeight","updateFrequency","updateCounter","moveStep","tangent","enemyTop","enemyLeft","createCanvasElement","render","prototype","canvas","style","top","left","update","xcenter","ycenter","Math","floor","cos","sin","document","createElement","width","height","className","appendChild","context","getContext","Object","defineProperty","value","TowerDefenseMap_1","Enemy_1","TowerDefenseGame","gameWidth","gameHeight","tickLength","secondsSinceStart","gameRunning","enemies","gameMap","default","setInitialState","testElement","getElementById","enemy","push","startGame","console","warn","lastRender","lastTick","performance","now","main","stopGame","window","cancelAnimationFrame","stopMain","resetGame","tickFrame","forEach","queueUpdates","numTicks","requestAnimationFrame","bind","nextTick","timeSinceTick","TowerDefenseMap","sections","padding","lineWidth","resize","_this","x","boardWidth","spaceBetweenSections","moveTo","lineTo","boardHeight","strokeStyle","stroke","TowerDefenseGame_1","onload","startButtonElement","stoptButtonElement","containerElement","MyGame","onclick"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","class Enemy {\n    private enemyWidth: number = 20;\n    private enemyHeight: number = 20;\n    private enemyTop: number;\n    private enemyLeft: number;\n    private updateFrequency: number = 100;\n    private updateCounter: number = this.updateFrequency;\n    private moveStep: number = 6;\n    private canvas: HTMLCanvasElement;\n    private context: CanvasRenderingContext2D;\n    private tangent: number = 0;\n\n    public render(): void {\n        this.canvas.style.top = `${this.enemyTop}px`;\n        this.canvas.style.left = `${this.enemyLeft}px`;\n    }\n\n    public update(): void {\n        if (this.updateCounter === this.updateFrequency) {\n            /*\n            if (this.enemyLeft < 400 && this.enemyLeft <= 200 ){\n                this.enemyLeft += this.moveStep;\n            } else if (this.enemyTop < 400) {\n                this.enemyTop += this.moveStep;\n            } else if (this.enemyTop >= 400){\n                this.enemyLeft -= this.moveStep;\n            } else if (this.enemyLeft >= 400) {\n                this.enemyTop -= this.moveStep;\n            }\n            */\n            this.tangent += 0.1;\n            var r = 100;\n            var xcenter = 300;\n            var ycenter = 300;\n            this.enemyLeft = Math.floor(xcenter + (r * Math.cos(this.tangent)));\n            this.enemyTop = Math.floor(ycenter + (r * Math.sin(this.tangent)));\n            \n        } else {\n            this.updateCounter ++;\n        }\n    }\n\n    private createCanvasElement(): void {\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.enemyWidth;\n        this.canvas.height = this.enemyHeight;\n        this.canvas.className = 'tower-defense-enemy';\n        this.rootElement.appendChild(this.canvas);\n        this.context = this.canvas.getContext(\"2d\");\n    }\n\n    constructor (private rootElement: HTMLElement){\n        this.enemyTop = 300;\n        this.enemyLeft = 400;\n        this.createCanvasElement();\n        this.render();\n    }\n}\n\nexport default Enemy;\n","import TowerDefenseMap from './TowerDefenseMap';\nimport Enemy from './Enemy';\n\n/**\n * Tower Defense Game\n */\nclass TowerDefenseGame {\n  // Identifier of the last requestAnimationFrame so we can stop the game.\n  public stopMain: number;\n  // Keeps track of the last update time. Always increments by tickLength.\n  public lastTick: number;\n  // Keeps track of the last provided requestAnimationFrame timestamp.\n  public lastRender: number;\n  // Set the simulation to run at 25Hz (40ms)\n  public tickLength: number = 40;\n  // Time since the game started in seconds\n  public secondsSinceStart: number = 0;\n  // Basic game state\n  private gameRunning: boolean = false;\n\n  private testElement: HTMLElement; // TODO: just for testing, remove this.\n  private gameMap: TowerDefenseMap;\n  private enemies: Enemy[] = [];\n\n  /**\n   * Initialize the game.\n   * Performs whatever tasks are leftover before the mainloop must run.\n   */\n  setInitialState():void {\n    // Render the map\n    this.gameMap.render();\n\n    // Create an enemy\n    let enemy: Enemy = new Enemy(this.rootElement);\n    this.enemies.push(enemy);\n  }\n\n  public startGame(): void {\n    if (this.gameRunning === false) {\n      console.warn('start game');\n      //Pretend the first draw was on first update.\n      this.lastRender = this.lastTick;\n      this.lastTick = performance.now();\n      this.gameRunning = true;\n\n      // Start the main loop\n      this.main(performance.now());\n    }\n  }\n\n  /**\n   * Method to stop the animation of the current game\n   */\n  public stopGame(): void {\n    if (this.gameRunning === true) {\n      console.warn('stop game');\n      this.gameRunning = false;\n      window.cancelAnimationFrame(this.stopMain);\n    }\n  }\n\n  /**\n   * Reset the game to the initial state\n   */\n  public resetGame(): void {\n    this.setInitialState();\n  }\n\n  /**\n   * Calculates the game state as of a given point in time. It should always\n   * increment by tickLength. It is the authority for game state. It is passed \n   * the DOMHighResTimeStamp for the time it represents (which, again, is always \n   * last update + MyGame.tickLength unless a pause feature is added, etc.)\n   */\n  private update(tickFrame: number){\n    // Test element\n    let secondsSinceStart: number = Math.floor(tickFrame / 1000);\n    if (secondsSinceStart > this.secondsSinceStart && Math.floor(tickFrame % 1000) < 100) {\n      this.secondsSinceStart = secondsSinceStart;\n      if (secondsSinceStart % 2 === 0){\n        this.testElement.style.left = '10px';\n      } else {\n        this.testElement.style.left = '570px';\n      }\n    }\n\n    // Enemies\n    this.enemies.forEach((enemy)=>{\n      enemy.update();\n    });\n  }\n\n  /**\n   * Is passed tickFrame because it is assumed that the render method will calculate\n   * how long it has been since the most recently passed update tick for \n   * extrapolation (purely cosmetic for fast devices). It draws the scene.\n   */\n  render(tickFrame: number){\n    this.enemies.forEach((enemy)=>{\n      enemy.render();\n    });\n  }\n\n  /**\n   * Call the update function every tickLength milliseconds.\n   */\n  private queueUpdates(numTicks: number) {\n    for(var i=0; i < numTicks; i++) {\n      // Now lastTick is this tick.\n      this.lastTick = this.lastTick + this.tickLength;\n      this.update(this.lastTick);\n    }\n  }\n\n  /**\n   * Game main loop\n   */\n  private main(tickFrame: number ){\n    this.stopMain = window.requestAnimationFrame(this.main.bind(this));\n    var nextTick = this.lastTick + this.tickLength;\n    var numTicks = 0;\n\n    // Keep track of how large numTicks is.\n    // If it is large, then either the game was asleep, or the machine cannot keep up.\n    if (tickFrame > nextTick) {\n      // Calculate the time between requestAnimationFrame callback and last update.\n      var timeSinceTick = tickFrame - this.lastTick;\n      numTicks = Math.floor(timeSinceTick / this.tickLength);\n    }\n\n    this.queueUpdates(numTicks);\n    this.render(tickFrame);\n    this.lastRender = tickFrame;\n  }\n\n  constructor(private rootElement: HTMLElement, \n  private gameWidth: number = 600,\n  private gameHeight: number = 600) {\n    this.gameMap = new TowerDefenseMap(rootElement, gameWidth, gameHeight);\n    // Init the state of the game\n    this.setInitialState();\n    this.testElement = document.getElementById('test');\n  }\n}\n\nexport default TowerDefenseGame;\n","class TowerDefenseMap {\n    padding: number = 10;\n    spaceBetweenSections: number;\n    boardWidth: number;\n    boardHeight: number;\n    lineWidth: number = 0.5;\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D;\n\n    public render(): void {\n        window.requestAnimationFrame(() => {\n            for (var x = 0; x <= this.boardWidth; x += this.spaceBetweenSections) {\n                this.context.moveTo(0.5 + x + this.padding, this.padding);\n                this.context.lineTo(0.5 + x + this.padding, this.boardHeight + this.padding);\n            }\n\n\n            for (var x = 0; x <= this.boardHeight; x += this.spaceBetweenSections) {\n                this.context.moveTo(this.padding, 0.5 + x + this.padding);\n                this.context.lineTo(this.boardWidth + this.padding, 0.5 + x + this.padding);\n            }\n\n            this.context.strokeStyle = \"black\";\n            this.context.stroke();\n        });\n    }\n\n    private resize(width: number, height: number): void {\n        this.boardWidth = this.width - 2 * this.padding;\n        this.boardHeight = this.height - 2 * this.padding;\n        this.spaceBetweenSections = this.boardWidth / this.sections;\n    }\n\n    private createCanvasElement(): void {\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        this.canvas.className = 'tower-defense-map';\n        this.rootElement.appendChild(this.canvas);\n        this.context = this.canvas.getContext(\"2d\");\n    }\n\n    constructor (private rootElement: HTMLElement, private width: number, private height: number, private sections: number = 16){\n        this.resize(width, height);\n        this.createCanvasElement();\n    }\n}\n\nexport default TowerDefenseMap;\n","'use strict';\n\nimport TowerDefenseGame from './TowerDefenseGame';\n\nwindow.onload = function() {\n  let startButtonElement: HTMLElement = document.getElementById('startButton');\n  let stoptButtonElement: HTMLElement = document.getElementById('stopButton');\n  let containerElement: HTMLElement = document.getElementById('container');\n  let MyGame: TowerDefenseGame = new TowerDefenseGame(containerElement);\n  \n  // Button event handler\n  startButtonElement.onclick = () => {MyGame.startGame()};\n  stoptButtonElement.onclick = () => {MyGame.stopGame()};\n}\n"]}