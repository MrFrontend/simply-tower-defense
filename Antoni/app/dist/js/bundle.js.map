{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/typescript/Enemy.ts","src/typescript/TowerDefenseGame.ts","src/typescript/TowerDefenseMap.ts","src/typescript/main.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Enemy","rootElement","this","enemyWidth","enemyHeight","updateFrequency","updateCounter","moveStep","tangent","enemyTop","enemyLeft","createCanvasElement","render","canvas","style","top","left","xcenter","ycenter","Math","floor","cos","sin","document","createElement","width","height","className","appendChild","context","getContext","Object","defineProperty","value","TowerDefenseMap_1","Enemy_1","TowerDefenseGame","gameWidth","arguments","undefined","gameHeight","tickLength","secondsSinceStart","gameRunning","enemies","gameMap","default","setInitialState","testElement","getElementById","enemy","push","console","warn","lastRender","lastTick","performance","now","main","window","cancelAnimationFrame","stopMain","tickFrame","forEach","update","numTicks","requestAnimationFrame","bind","nextTick","timeSinceTick","queueUpdates","TowerDefenseMap","sections","padding","lineWidth","resize","x","_this","boardWidth","spaceBetweenSections","moveTo","lineTo","boardHeight","strokeStyle","stroke","TowerDefenseGame_1","onload","startButtonElement","stoptButtonElement","containerElement","MyGame","onclick","startGame","stopGame"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","class Enemy {\n    private enemyWidth: number = 20;\n    private enemyHeight: number = 20;\n    private enemyTop: number;\n    private enemyLeft: number;\n    private updateFrequency: number = 100;\n    private updateCounter: number = this.updateFrequency;\n    private moveStep: number = 6;\n    private canvas: HTMLCanvasElement;\n    private context: CanvasRenderingContext2D;\n    private tangent: number = 0;\n\n    public render(): void {\n        this.canvas.style.top = `${this.enemyTop}px`;\n        this.canvas.style.left = `${this.enemyLeft}px`;\n    }\n\n    public update(): void {\n        if (this.updateCounter === this.updateFrequency) {\n            /*\n            if (this.enemyLeft < 400 && this.enemyLeft <= 200 ){\n                this.enemyLeft += this.moveStep;\n            } else if (this.enemyTop < 400) {\n                this.enemyTop += this.moveStep;\n            } else if (this.enemyTop >= 400){\n                this.enemyLeft -= this.moveStep;\n            } else if (this.enemyLeft >= 400) {\n                this.enemyTop -= this.moveStep;\n            }\n            */\n            this.tangent += 0.1;\n            var r = 100;\n            var xcenter = 300;\n            var ycenter = 300;\n            this.enemyLeft = Math.floor(xcenter + (r * Math.cos(this.tangent)));\n            this.enemyTop = Math.floor(ycenter + (r * Math.sin(this.tangent)));\n            \n        } else {\n            this.updateCounter ++;\n        }\n    }\n\n    private createCanvasElement(): void {\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.enemyWidth;\n        this.canvas.height = this.enemyHeight;\n        this.canvas.className = 'tower-defense-enemy';\n        this.rootElement.appendChild(this.canvas);\n        this.context = this.canvas.getContext(\"2d\");\n    }\n\n    constructor (private rootElement: HTMLElement){\n        this.enemyTop = 300;\n        this.enemyLeft = 400;\n        this.createCanvasElement();\n        this.render();\n    }\n}\n\nexport default Enemy;\n","import TowerDefenseMap from './TowerDefenseMap';\nimport Enemy from './Enemy';\n\n/**\n * Tower Defense Game\n */\nclass TowerDefenseGame {\n  // Identifier of the last requestAnimationFrame so we can stop the game.\n  public stopMain: number;\n  // Keeps track of the last update time. Always increments by tickLength.\n  public lastTick: number;\n  // Keeps track of the last provided requestAnimationFrame timestamp.\n  public lastRender: number;\n  // Set the simulation to run at 25Hz (40ms)\n  public tickLength: number = 40;\n  // Time since the game started in seconds\n  public secondsSinceStart: number = 0;\n  // Basic game state\n  private gameRunning: boolean = false;\n\n  private testElement: HTMLElement; // TODO: just for testing, remove this.\n  private gameMap: TowerDefenseMap;\n  private enemies: Enemy[] = [];\n\n  /**\n   * Initialize the game.\n   * Performs whatever tasks are leftover before the mainloop must run.\n   */\n  setInitialState():void {\n    // Render the map\n    this.gameMap.render();\n\n    // Create an enemy\n    let enemy: Enemy = new Enemy(this.rootElement);\n    this.enemies.push(enemy);\n  }\n\n  public startGame(): void {\n    if (this.gameRunning === false) {\n      console.warn('start game');\n      //Pretend the first draw was on first update.\n      this.lastRender = this.lastTick;\n      this.lastTick = performance.now();\n      this.gameRunning = true;\n\n      // Start the main loop\n      this.main(performance.now());\n    }\n  }\n\n  /**\n   * Method to stop the animation of the current game\n   */\n  public stopGame(): void {\n    if (this.gameRunning === true) {\n      console.warn('stop game');\n      this.gameRunning = false;\n      window.cancelAnimationFrame(this.stopMain);\n    }\n  }\n\n  /**\n   * Reset the game to the initial state\n   */\n  public resetGame(): void {\n    this.setInitialState();\n  }\n\n  /**\n   * Calculates the game state as of a given point in time. It should always\n   * increment by tickLength. It is the authority for game state. It is passed \n   * the DOMHighResTimeStamp for the time it represents (which, again, is always \n   * last update + MyGame.tickLength unless a pause feature is added, etc.)\n   */\n  private update(tickFrame: number){\n    // Test element\n    let secondsSinceStart: number = Math.floor(tickFrame / 1000);\n    if (secondsSinceStart > this.secondsSinceStart && Math.floor(tickFrame % 1000) < 100) {\n      this.secondsSinceStart = secondsSinceStart;\n      if (secondsSinceStart % 2 === 0){\n        this.testElement.style.left = '10px';\n      } else {\n        this.testElement.style.left = '570px';\n      }\n    }\n\n    // Enemies\n    this.enemies.forEach((enemy)=>{\n      enemy.update();\n    });\n  }\n\n  /**\n   * Is passed tickFrame because it is assumed that the render method will calculate\n   * how long it has been since the most recently passed update tick for \n   * extrapolation (purely cosmetic for fast devices). It draws the scene.\n   */\n  render(tickFrame: number){\n    this.enemies.forEach((enemy)=>{\n      enemy.render();\n    });\n  }\n\n  /**\n   * Call the update function every tickLength milliseconds.\n   */\n  private queueUpdates(numTicks: number) {\n    for(var i=0; i < numTicks; i++) {\n      // Now lastTick is this tick.\n      this.lastTick = this.lastTick + this.tickLength;\n      this.update(this.lastTick);\n    }\n  }\n\n  /**\n   * Game main loop\n   */\n  private main(tickFrame: number ){\n    this.stopMain = window.requestAnimationFrame(this.main.bind(this));\n    var nextTick = this.lastTick + this.tickLength;\n    var numTicks = 0;\n\n    // Keep track of how large numTicks is.\n    // If it is large, then either the game was asleep, or the machine cannot keep up.\n    if (tickFrame > nextTick) {\n      // Calculate the time between requestAnimationFrame callback and last update.\n      var timeSinceTick = tickFrame - this.lastTick;\n      numTicks = Math.floor(timeSinceTick / this.tickLength);\n    }\n\n    this.queueUpdates(numTicks);\n    this.render(tickFrame);\n    this.lastRender = tickFrame;\n  }\n\n  constructor(private rootElement: HTMLElement, \n  private gameWidth: number = 600,\n  private gameHeight: number = 600) {\n    this.gameMap = new TowerDefenseMap(rootElement, gameWidth, gameHeight);\n    // Init the state of the game\n    this.setInitialState();\n    this.testElement = document.getElementById('test');\n  }\n}\n\nexport default TowerDefenseGame;\n","class TowerDefenseMap {\n    padding: number = 10;\n    spaceBetweenSections: number;\n    boardWidth: number;\n    boardHeight: number;\n    lineWidth: number = 0.5;\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D;\n\n    public render(): void {\n        window.requestAnimationFrame(() => {\n            for (var x = 0; x <= this.boardWidth; x += this.spaceBetweenSections) {\n                this.context.moveTo(0.5 + x + this.padding, this.padding);\n                this.context.lineTo(0.5 + x + this.padding, this.boardHeight + this.padding);\n            }\n\n\n            for (var x = 0; x <= this.boardHeight; x += this.spaceBetweenSections) {\n                this.context.moveTo(this.padding, 0.5 + x + this.padding);\n                this.context.lineTo(this.boardWidth + this.padding, 0.5 + x + this.padding);\n            }\n\n            this.context.strokeStyle = \"black\";\n            this.context.stroke();\n        });\n    }\n\n    private resize(width: number, height: number): void {\n        this.boardWidth = this.width - 2 * this.padding;\n        this.boardHeight = this.height - 2 * this.padding;\n        this.spaceBetweenSections = this.boardWidth / this.sections;\n    }\n\n    private createCanvasElement(): void {\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.width;\n        this.canvas.height = this.height;\n        this.canvas.className = 'tower-defense-map';\n        this.rootElement.appendChild(this.canvas);\n        this.context = this.canvas.getContext(\"2d\");\n    }\n\n    constructor (private rootElement: HTMLElement, private width: number, private height: number, private sections: number = 16){\n        this.resize(width, height);\n        this.createCanvasElement();\n    }\n}\n\nexport default TowerDefenseMap;\n","'use strict';\n\nimport TowerDefenseGame from './TowerDefenseGame';\n\nwindow.onload = function() {\n  let startButtonElement: HTMLElement = document.getElementById('startButton');\n  let stoptButtonElement: HTMLElement = document.getElementById('stopButton');\n  let containerElement: HTMLElement = document.getElementById('container');\n  let MyGame: TowerDefenseGame = new TowerDefenseGame(containerElement);\n  \n  // Button event handler\n  startButtonElement.onclick = () => {MyGame.startGame()};\n  stoptButtonElement.onclick = () => {MyGame.stopGame()};\n}\n"]}