{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/typescript/TowerDefenseGame.ts","src/typescript/main.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","TowerDefenseGame","this","tickLength","secondsSinceStart","gameRunning","setInitialState","testElement","document","getElementById","prototype","console","log","startGame","warn","lastRender","lastTick","performance","now","main","stopGame","window","cancelAnimationFrame","stopMain","resetGame","update","tickFrame","Math","floor","style","left","render","queueUpdates","numTicks","requestAnimationFrame","bind","nextTick","timeSinceTick","Object","defineProperty","value","TowerDefenseGame_1","onload","startButtonElement","stoptButtonElement","MyGame","default","onclick"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Tower Defense Game\n */\nclass TowerDefenseGame {\n  // Identifier of the last requestAnimationFrame so we can stop the game.\n  public stopMain: number;\n  // Keeps track of the last update time. Always increments by tickLength.\n  public lastTick: number;\n  // Keeps track of the last provided requestAnimationFrame timestamp.\n  public lastRender: number;\n  // Set the simulation to run at 25Hz (40ms)\n  public tickLength: number = 40;\n  // Time since the game started in seconds\n  public secondsSinceStart: number = 0;\n  // Basic game state\n  private gameRunning: boolean = false;\n\n  private testElement: HTMLElement; // TODO: just for testing, remove this.\n\n  /**\n   * Initialize the game.\n   * Performs whatever tasks are leftover before the mainloop must run.\n   */\n  setInitialState():void {\n    console.log('setInitialState');\n  }\n\n  public startGame(): void {\n    if (this.gameRunning === false) {\n      console.warn('start game');\n      //Pretend the first draw was on first update.\n      this.lastRender = this.lastTick;\n      this.lastTick = performance.now();\n      this.gameRunning = true;\n\n      // Start the main loop\n      this.main(performance.now());\n    }\n  }\n\n  /**\n   * Method to stop the animation of the current game\n   */\n  public stopGame(): void {\n    if (this.gameRunning === true) {\n      console.warn('stop game');\n      this.gameRunning = false;\n      window.cancelAnimationFrame(this.stopMain);\n    }\n  }\n\n  /**\n   * Reset the game to the initial state\n   */\n  public resetGame(): void {\n    this.setInitialState();\n  }\n\n  /**\n   * Calculates the game state as of a given point in time. It should always\n   * increment by tickLength. It is the authority for game state. It is passed \n   * the DOMHighResTimeStamp for the time it represents (which, again, is always \n   * last update + MyGame.tickLength unless a pause feature is added, etc.)\n   */\n  private update(tickFrame: number){\n    let secondsSinceStart: number = Math.floor(tickFrame / 1000);\n\n    if (secondsSinceStart > this.secondsSinceStart && Math.floor(tickFrame % 1000) < 100) {\n      this.secondsSinceStart = secondsSinceStart;\n      if (secondsSinceStart % 2 === 0){\n        this.testElement.style.left = '10px';\n      } else {\n        this.testElement.style.left = '570px';\n      }\n      \n    }\n  }\n\n  /**\n   * Is passed tickFrame because it is assumed that the render method will calculate\n   * how long it has been since the most recently passed update tick for \n   * extrapolation (purely cosmetic for fast devices). It draws the scene.\n   */\n  render(tickFrame: number){\n    // Something will happen here at some point :)\n  }\n\n  /**\n   * Call the update function every tickLength milliseconds.\n   */\n  private queueUpdates(numTicks: number) {\n    for(var i=0; i < numTicks; i++) {\n      // Now lastTick is this tick.\n      this.lastTick = this.lastTick + this.tickLength;\n      this.update(this.lastTick);\n    }\n  }\n\n  /**\n   * Game main loop\n   */\n  private main(tickFrame: number ){\n    this.stopMain = window.requestAnimationFrame(this.main.bind(this));\n    var nextTick = this.lastTick + this.tickLength;\n    var numTicks = 0;\n\n    // Keep track of how large numTicks is.\n    // If it is large, then either the game was asleep, or the machine cannot keep up.\n    if (tickFrame > nextTick) {\n      // Calculate the time between requestAnimationFrame callback and last update.\n      var timeSinceTick = tickFrame - this.lastTick;\n      numTicks = Math.floor(timeSinceTick / this.tickLength);\n    }\n\n    this.queueUpdates(numTicks);\n    this.render(tickFrame);\n    this.lastRender = tickFrame;\n  }\n\n  constructor() {\n    // Init the state of the game\n    this.setInitialState();\n    this.testElement = document.getElementById('test');\n  }\n}\n\nexport default TowerDefenseGame;","'use strict';\n\nimport TowerDefenseGame from './TowerDefenseGame';\n\nwindow.onload = function() {\n  let startButtonElement: HTMLElement = document.getElementById('startButton');\n  let stoptButtonElement: HTMLElement = document.getElementById('stopButton');\n  let MyGame: TowerDefenseGame = new TowerDefenseGame();\n  \n  // Button event handler\n  startButtonElement.onclick = () => {MyGame.startGame()};\n  stoptButtonElement.onclick = () => {MyGame.stopGame()};\n}\n"]}